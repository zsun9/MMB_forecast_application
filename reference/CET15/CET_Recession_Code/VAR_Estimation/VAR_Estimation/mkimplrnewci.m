function [simimp,simvd,simdataout,count_var_expl,EtechtabStd,NtechtabStd,montabStd, ...
        alltabStd,histhpStd,histbpStd,PortStatData,PortSimMat, ...
        Etechtabmean,Ntechtabmean,montabmean,alltabmean,histhpmean,histbpmean] ...
          = mkimplrnewci(vardata,nlags,nstep,hasconst,trendval,vardetrend,fflocation,sortlev,ndraws,PortmanteauLags,a,b,lam,truncdate);
      
% MKIMPLRCI : A program to simulate Impulse Responses and VAriance Decompositions from a Long Run VAR with a permanent shock to productivity. 
% Optionally one can also impose a Fed Funds Restriction, in order to identify a monetary policy shock. 
% Calling the program. 
% mkimplrnew(vardata,nlags,nstep,hasconst,trendval,vardetrend,fflocation,sortlev);
% REQUIRED INPUTS
% vardata: Date used for the VAR, each variable is in a column. It is assumed that the permnent shocked variable is listed first. 
% In other words, that either labor productivity growth or output growth is listed first. 
% NLAGS is the number of lags in the VAR. 
% NSTEP is the number of steps out to calculate the impulse responses. 
% OPTIONAL INPUTS 
% HASCONST determines whether the VAR has a constant. 1 equals yes. 
% TRENDVAL is the degree of the time-trend polynomial to remove from the variables listed in vardetrend
% VARDETREND is what variables are in teh VAR. 
% FFLOCATION describes where the Fed Funds rate is. (In other words for all variables above this will be assumeed to have 
% a block recursive form. 
% ie  A_0 = [A 0; B C] where A is (FFLocation-1) by (FFLocation-1) square. 
% SORTLEV is the name of the file used to sort out the variables and put them in level
% in other words, you might estimate the var (dy dh) and   want impulse responses for 
% for Y and H. The program sortlew will describe how to change (dy dh) into (y h). 
% NDRAWS the number of simulations to generate. 
% OUTPUT FROM THE PROGRAM
% SIMIMP are the simulated impulse responses they are a multidimensional matrix that the number of rows is the number of steps.
% the columns are the variables and the third dimension (the worksheet) are the different shocks, the fourth dimension describes the total number of simulations. 
% SIMVD is the variance decompositions.  It has the same format as SIMIMP. 

%By Robert Vigfusson August 2002

%Modified by Jesper Lindé October 2004 so that it reports standard errors
%for the ndraws of all the matrices generated by getvardecomp, we call
%these matrices
%EtechtabStd,NtechtabStd,montabStd,alltabStd,histhpStd,histbpStd
%Note that these standard errors are based on stable VARs only. See lines
%130-160
%Also report Portmanteau statistics, both actual and simulated, see main.m
%and lines 57-61 and and 126-129

% Set seed so that results can be exactly replicated in a given Matlab version
randn('state',123456);
rand('state',123456);

if nargin < 14;
   truncdate = 1;
end

[trimpzout,trvdout,trsimdataout,trerzout,trazero,tra0betaz] = mkimplrnew(vardata,nlags,nstep,hasconst,trendval,vardetrend,fflocation,sortlev);
vardata = detrendrjv(vardata,trendval,vardetrend); %knock the trends out of the initial conditions. 

clear trsimdataout

uz = trerzout;
betavar = tra0betaz';
a0inv = inv(trazero);

%Compute Portmanteau statistics on the actual innovations - erzout
test=1;
for i=1:length(PortmanteauLags);
    [qstat,dof,pvalue] = mkqmv(uz,PortmanteauLags(i),nlags,test);
    PortStatData(:,i)=[qstat,pvalue,dof]';
end;
test=0;%for the bootstrap simulations, don't compute p-values or degrees of freedom
PortSimMat = zeros(ndraws,length(PortmanteauLags));

%declare matricies
simimp       =   zeros([size(trimpzout) ndraws]);
simvd       =   zeros([size(trvdout ) ndraws]);
%simdataout  =  NaN*zeros([size(trerzout) size(trvdout,3 )+1 ndraws]);
 


[nobs,nvars] = size(vardata);  %number of variables
nobs = nobs-nlags;

%do simulations. 
icnt=1;
count_var_expl=0;
while icnt<=ndraws
    
    disp(['Now doing trial ' num2str(icnt) ' out of ' num2str(ndraws)])
   %loop over the number of draws
   % generate data 
   % and then calculate impulse response functions
   
   % step 1 generate the data
   % bootstrap off structural errors
   erz = uz(ceil(size(uz,1)*rand(nobs,1)),:);
   %I generate a random number bounded between 0 and # of residuals
   %I then use the ceil function to select that row of the residuals
   %this is equivalent to sampling with replacement.    
   ydata = zeros(nobs+nlags,nvars);
   ydata(1:nlags,1:nvars) = vardata(1:nlags,1:end); %use the original values as starting values
   
   %set up lagged values. 
   zlag = reshape(ydata(nlags:-1:1,1:nvars)',1,nlags*nvars);
   %generate simulated data. 
   for jj=nlags+(1:nobs);
      ydata(jj,:)=betavar(hasconst,:)+zlag*betavar(hasconst+1:size(betavar,1),:)+(a0inv*erz(jj-nlags,:)')';
      zlag = [ydata(jj,:) zlag(1,1:(nlags-1)*nvars)];
   end;
   
   %calculate simulate data and variance decompositions.  
%    if ndims(simimp)>3;
%       
%       if nargout == 2;
%          [simimp(:,:,:,icnt),simvd(:,:,:,icnt)] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
%       elseif nargout == 1;
%          [simimp(:,:,:,icnt)] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
%       else
%          error('wrong number of output arguments')
%       end
%    else
%       if nargout == 2;
%          [simimp(:,:,icnt),simvd(:,:,icnt)] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
%       elseif nargout == 1;
%          [simimp(:,:,icnt)] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
%       else
%          error('wrong number of output arguments')
%       end
%    end
   if ndims(simimp)>3;
      %ADJUSTED; %For Speed and Memory reasons. 
         %[simimp(:,:,:,icnt),simvd(:,:,:,icnt),simdataout(:,:,:,icnt),erzout,azeroout,a0betazout,var_explode,V,D] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
           [simimp(:,:,:,icnt),simvd(:,:,:,icnt),simdataout,erzout,azeroout,a0betazout,var_explode,V,D] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
          else
   %      [simimp(:,:,icnt),simvd(:,:,icnt),simdataout(:,:,:,icnt),erzout,azeroout,a0betazout,var_explode,V,D] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
     [simimp(:,:,icnt),simvd(:,:,icnt),simdataout,erzout,azeroout,a0betazout,var_explode,V,D] = mkimplrnew(ydata(truncdate:end,:),nlags,nstep,hasconst,0,[],fflocation,sortlev);
     
   end
   
   pack
   
if var_explode>0
    icnt = icnt-1;
    count_var_expl = count_var_expl+1;
else
    
   %Compute Portmanteau statistics on the innovations - erzout
   for i=1:length(PortmanteauLags);
       [qstat,dof,pvalue] = mkqmv(erzout,PortmanteauLags(i),nlags,test);
       PortSimMat(icnt,i)=qstat;
   end;

   %Compute variance decompositions (this has to be fixed because the code
   %is hardwired for the ACEL data set)
%    [Etechtab,Ntechtab,montab,alltab,histhp,histbp,varnamz,hornmz] = getvardecomp(a,b,lam,squeeze(simdataout(:,:,:,icnt)),squeeze(simvd(:,:,:,icnt)),erzout,azeroout,a0betazout);
%    if icnt == 1;
%       EtechtabStd=zeros([ndraws size(Etechtab)]);
%       NtechtabStd=zeros([ndraws size(Ntechtab)]);
%       montabStd  =zeros([ndraws size(montab)]);
%       alltabStd  =zeros([ndraws size(alltab)]);
%       histhpStd  =zeros([ndraws size(histhp)]);
%       histbpStd  =zeros([ndraws size(histbp)]);
%    end;
%    EtechtabStd(icnt,:,:) = Etechtab;
%    NtechtabStd(icnt,:,:) = Ntechtab;
%    montabStd(icnt,:,:)   = montab;
%    alltabStd(icnt,:,:)   = alltab;
%    histhpStd(icnt,:,:)   = histhp;
%    histbpStd(icnt,:,:)   = histbp;
end
icnt=icnt+1;
end;

%Computing the standard errors for each 3 dimensional matrix
%EtechtabStd,...histpbStd
%needs to be fixed, because hardwired for ACEL
% for ii = 1:11
%     for jj = 1:7
%         Etechtabmean(ii,jj)=mean(EtechtabStd(:,ii,jj));
%         Ntechtabmean(ii,jj)=mean(NtechtabStd(:,ii,jj));
%         montabmean(ii,jj)=mean(montabStd(:,ii,jj));
%         alltabmean(ii,jj)=mean(alltabStd(:,ii,jj));
%     end
%     for jj = 1:4
%        histhpmean(ii,jj)=mean(histhpStd(:,ii,jj));
%        histbpmean(ii,jj)=mean(histbpStd(:,ii,jj));
%    end
% end

% EtechtabStd = squeeze(std(EtechtabStd,1));%1 indicates normalizing with ndraws
% NtechtabStd = squeeze(std(NtechtabStd,1));
% montabStd   = squeeze(std(montabStd,1));
% alltabStd   = squeeze(std(alltabStd,1));
% histhpStd   = squeeze(std(histhpStd,1));
% histbpStd   = squeeze(std(histbpStd,1));

%the following are empty because adjustments are required to apply this to
%the Riksbank project
EtechtabStd = [];
NtechtabStd = [];
montabStd   = [];
alltabStd   = [];
histhpStd   = [];
histbpStd   = [];
Etechtabmean= [];
Ntechtabmean= [];
montabmean= [];
alltabmean= [];
histhpmean= [];
histbpmean= [];
 
 